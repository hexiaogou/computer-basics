### 进位计数制

第一章：现代计算机的结构主要分为五大部件，主机（CPU（运算器、控制器），主存（MAR、MDR）），I/O设备

主存储器可以用来存放数据 -- 数据如何在计算机中表示？即如何用二进制来表示？

运算器可以进行数学运算和逻辑运算 -- 运算器如何实现数据的算数、逻辑运算？

##### 十、二、八、十六

十进制、二进制、八进制、十六进制

日常用的计算是十进制，计算机能处理的是二进制，为了方便程序员阅读和记录也引入了八进制、十六进制

其他进制 ----> 十进制；二进制、八进制、十六进制之间的转换；十进制 ----> 其他进制；真值和机器数



最古老计数方法

画横线或竖线来表示事物数量 -- 没办法表示数量很多的情况

用不同的符号表示不同的数量 -- 符号反映权重

罗马数字的几种符号与对应权重

| 基本字符               | I    | V    | X    | L    | C    | D    | M    |
| ---------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 相应的阿拉伯数字表示为 | 1    | 5    | 10   | 50   | 100  | 500  | 1000 |

I - 1、II - 2、III - 3、IV（中世纪之后） - 4、V - 5、MDCCCLXXXVIII - 1888

<span style="color:red">基于“加法”思想的计数方法</span> -- 数字不断增大需要发明更多的符号



十进制计数法

古印度人发明的阿拉伯数字：0，1，2，3，4，5，6，7，8，9。由阿拉伯传入欧洲，欧洲人就以为是阿拉伯人发明的。

每个数字符号反映权重，十进制，符号所在的位置也反映权重

=> 十进制：KnKn-1....K2K1K0K-1K-2..K-n= Kn x 10ⁿ + Kn-1 x 10ⁿ-1 .... + K2 x 10² + K1 x 10¹ + K0 x 10⁰ + K-1 x 10^-1 + K-2 x 10^-2 + K-n x 10^-n(数码位 x 实际的权值)

<span style="color:red">基于“乘法”思想的计数方法</span> （由位置确定的权重定义为位权）

有0～9，共十种符号，逢十进一的进位计数制 

🐶：八进制的发明者是海绵宝宝



推广：r进制计数法

r进制：KnKn-1....K2K1K0K-1K-2..K-m= Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰ + K-1 x r^-1 + K-2 x r^-2 + K-n x r^-m(数码位 x 实际的权值)

<span style="color:green">基数</span> ：每个数码位所用到的不同符号的个数，r进制的计数为r。Eg：古巴比伦时期用到60进制，现代也使用广泛，比如时间的利用

二进制：0、1（最适合计算机的计数方式）

八进制：0、1、2、3、4、5、6、7

十进制：0、1、2、3、4、5、6、7、8、9

十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F

二进制数：101.1 --> 1 x 2^2 + 0 x 2^1 + 1 x 2^0 + 1 x 2^-1 = 5.5

八进制数：5.4 --> 5 x 8^0 + 4 x 8^-1 = 5.5

十进制数：5.5 --> 5 x 10^0 + 5 x 10^-1 = 5.5

十六进制：5.8 --> 5 x 16^0 + 8 x 16^-1 = 5.5

最适合计算机的计数方式：①可以使用两个稳定状态的物理器件表示。②0、1正好对应逻辑值假、真，方便实现逻辑运算

③可以很方便使用逻辑门电路（数字电路 ）（处理二进制电路的元器件）实现算术运算

八进制、十六进制能和二进制能很好地对应



##### 任意进制 -> 十进制

不同的数码位在不同的位置有不同的位权

KnKn-1....K2K1K0K-1K-2..K-m= Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰ + K-1 x r^-1 + K-2 x r^-2 + K-n x r^-m(数码位 x 实际的权值)

10010010.110

| ...  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    | 0.5  | 0.25 | 0.125 | ...  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- |
| ...  | 1    | 0    | 0    | 1    | 0    | 0    | 1    | 0    | 1    | 1    | 0     |      |

=> 128 + 16 + 2 + 0.5 +0.25 = 146.75

1/8 = 0.125

1/16 = 0.0625



##### 二进制 <->八、十六进制

<span style="color:green">二进制 --> 八进制：3位一组，每组转换成相应的八进制符号</span> 

<span style="color:green">二进制 --> 十六进制：4位一组，每组转换成相应的十六进制符号</span>

<span style="color:green">八进制 --> 二进制：每位八进制对应3位二进制</span>

(251.5)8 --> (010 101 001.101)2

<span style="color:green">十六进制 --> 二进制：每位十六进制对应4位二进制</span>

(AE86.1)16 --> (1010 1110 1000 0110.0001)2

进制的书写方式：

二进制：(010 101 001.101)2 、010 101 001.101B

八进制：(251.5)8

十六进制(hexadecimal)：(AE86.1)16、AE86.1H、0xAE86.1

十进制(decimalism)：(4312)10、4313D



##### 十进制 -> 任意进制

r进制：KnKn-1....K2K1K0K-1K-2..K-m= Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰ + K-1 x r^-1 + K-2 x r^-2 + K-n x r^-m(数码位 x 实际的权值)

分为整数部分和小数部分来处理

Eg: 75.3 整数部分 = 75，Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰  = 75

（Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰ ）/ r = Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r⁰ (商) ... K0（余数）

 任何一个数码位的值Ki < r：0～r-1 

(rx+K0)/r ，

如十进制  -> 二进制 r=2

75 / 2 = 37 ... 1 => K0 = 1

37 / 2 = 18 ... 1 => K1 = 1

18 / 2 = 9 ...    0 => K2 = 0

9   / 2 = 4 ...    1  => K3 =1

4   / 2 = 2 ...    0   => K4 = 0

2 /  2 = 1 ...     0    => K5 = 0

1 /  2 = 0 ...     1    => K6 = 1

=> 75D = 1001011B

用短除法比较快 <span style="color:red">除基取余法</span> 

小数部分 = 0.3， K-1 x r^-1 + K-2 x r^-2 + K-n x r^-m = 0.3

( K-1 x r^-1 + K-2 x r^-2 + K-m x r^-m ) x r = K -1 + K-2 x r^-1 +... K-m x r^-(m-1)

K-1 -- 整数， K-2 x r^-1 +... K-m x r^-(m-1) --小数

如十进制  -> 二进制 r=2

0.3 x 2 = 0.6 = 0 + 0.6 => K-1 = 0

0.6 x 2 = 1.2 = 1 + 0.2 => K-2 = 1

0.2 x 2 = 0.4 = 0 + 0.4  => K-3 = 0

0.4 x 2 = 0.8 = 0 + 0.8  => K-4 = 0

0.8 x 2 = 1.6 = 1 + 0.6  =>  K-5 = 1

0.6 x 2 = 1.2 = 1 +  0.2  => K-6 = 1

=> 0.3D = .010011001......B（二进制精确到小数点后5位即 .01001......B）

十进制表示的0.3没办法用二进制数精确地来表示

用短乘法比较快<span style="color:red">乘基取整法</span> 

十进制 -> 二进制（拼凑法）

十进制数：260.75、533.125

| 2¹²  | 2¹¹  | 2¹⁰  | 2⁹   | 2⁸   | 2⁷   | 2⁶   | 2⁵   | 2⁴   | 2³   | 2²   | 2¹   | 2⁰   | 2⁻¹  | 2⁻²  | 2⁻³   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
| 4096 | 2048 | 1024 | 512  | 256  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    | 0.5  | 0.25 | 0.125 |

=> 260.75 = 256 + 4 + 0.5 +0.25 => 1000000100.11

=> 533.125 = 512 + 16 + 4 + 1 + 0.125 = 1000010101.001

##### 真值和机器数

15 -> 1111 

8 -> 1000

+15 -> 0 1111

-8 ->    1 1000

--原码、反码、补码、移码

真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式，正负号需要被数字化

### BCD码

二进制：0、1（最适合计算机的计数方式）

十进制：0、1、2、3、4、5、6、7、8、9（符合人类习惯）

4bit B （2⁴ = 16种状态、0～9利用，6中状态冗余）-> 1 个，即每四个的二进制位对应一个十进制的字符

快速转换 -- 一一对应

Binary Code Decimal：用二进制编码的十进制

##### 8421码

<span style="color:red">掌握加法运算</span> 

四个二进制位的权重分别为8421

---------------------------------------------------------->8421<----------------------------------------------------------

----------------------------------------------------------><span style="color:red">XXXX</span> <----------------------------------------------------------

Eg: 5 = 0101，9 = 1001

8421码的映射关系

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

985 = 1001 1000 0101

5 + 8 = 13 

0101 + 1000 --> ALU算术逻辑单元 --> 1101(不在映射表里)，8421码中 1010～1111没有定义 -> 基础上再加上 6，保证10 + 6能进一 --> 13 + 6 = 1101 + 0110 = 10011，对应8421编码为 13<span style="color:red">秒啊</span> 

即落在非法区间 + 6修正

9 + 9  = 1001 + 1001 = 10010 超出 1111表示范围，同样还是 + 6 = 10010 + 0110 = 11000 = 18

即8421码中 1010～10010没有定义的范围内，都需要进行 + 6的修正

[注意]若加法结果在合法范围内，则无需修正

BCD码直接使用其中的10中规则 --> 不同的映射方案

##### 余3码

8421码 + (0011)2 ，3～12

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

四个二进制位每个二进制位没有一个固定的权值

---------------------------------------------------------->YZMN<----------------------------------------------------------

----------------------------------------------------------><span style="color:red">XXXX</span> <----------------------------------------------------------

=> 8421码为有权码，余3码为无权码

##### 2421码

改变权值定义

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

----------------------------------------------------------------------------><span style="color:red">|</span> <---------------------------------------------------------------------------

2421码规则跟8421码规则类似，

---------------------------------------------------------->2421<----------------------------------------------------------

----------------------------------------------------------><span style="color:red">XXXX</span> <----------------------------------------------------------

0～4 最高位编码为0

5～9 最高位编码为1

这种策略让2421码编码达到统一



### 字符与字符串

之前学的是数字在计算机内如何进行表示

##### 英文字符

ASCII码：数字、字母、符号 --映射--> 共128个字符（常用的英文字符或控制字符） --> 7位二进制编码

为了存入计算机，通常在最高位补0，凑足1B

<span style="color:red">可印刷字符32～126，其余为控制，通信字符</span> （0～31、127）

Eg：6 -- ACK 字符，计算机通信字符

数字：<span style="color:green">48~57(0011 0000~0011 1001):0~9</span> ，后4个bit位对应的是字符的BCD码，确切的是8421码

大写字母：<span style="color:green">65~90(0100 0001~0101 1010)</span> 、前三bit - 0100，(0001~1010) - 1 ~ 26

小写字母：<span style="color:green">97~122(0110 0001~0111 1010)</span> 、前三bit - 0110，(0001~1010) - 1 ~ 26

Eg：已知'A'的ASCII码为65，字符'H'存放在某存储单元M种，求M中存放的内容

思路1: H - 72(0100 1000) (72 =  65 + (8 - 1))

思路2: A - 65(0100 0001) => H(0100 1000)(第八个)

Eg：已知'h'的ASCII码为104，字符'a'存放在存储单元M1中，字符'z'存放在存储单元M2中，求M1、M2中存放的内容

M1 - h - 104 - (0110 1000)

M2 - z  96 + 26=122 - (0111 1010)

##### 中文字符

GB2312 - 80 :汉字 + 各种符号 7445个，常用的有几万个汉字字符

区位码：94个区，每个区94个位置(直观、方便人类理解)

啊 - 16 01 - 10H 01H (十六进制和二进制可以很方便进行转换)

区位码 + 20H(32) 可以避免ASCII码通信字符的冲突，防止信息交换时与“控制与通信字符”冲突

=>

啊 - 16 01 - 10H 01H ->+20H -> 30H 21H(国标码)

汉字内码：国标码基础上 + 80H

=> 

啊 - 16 01 - 10H 01H ->+20H -> 30H 21H(国标码) -> +80H -> B0H A1H(汉字内码) (保证高位为1，与ASCII区分)

UTF-8编码方式：🦮

输入：输入编码

输出：汉字字形码

##### 字符串的存储

某计算机<span style="color:red">按字节编址</span> (每个地址对应1B)，从地址为2的单元开始，存储字符串“abc”

各字符对应的ASCII编码为

'a' = 0110 0001 = 61H

'b' = 0110 0010 = 62H

'c' = 0110  0011 = 63H

从低地址到高地址依次存放：61H、62H、63H、00H

'\0': 0000 0000 = 00H(很多语言中，'\0'作为字符串结尾标志)

某计算机<span style="color:red">按字节编址</span> (每个地址对应1B)，从地址为2的单元开始，存储字符串“abc啊”

各字符对应的ASCII编码为

'a' = 0110 0001 = 61H

'b' = 0110 0010 = 62H

'c' = 0110  0011 = 63H

'啊' = 区位码 -> 国标码 -> 汉字内码<span style="color:red">机内码</span>  = B0 A1H

从低地址到高地址依次存放：61H、62H、63H、B0H、A1H、00H (大端模型：将数据的最高有效字节存放在低地址单元中)

也可以：61H、62H、63H、A1H、B0H、00H(小端模型：将数据的最高有效字节存放在高地址单元中)

2B 对应的高位和低位顺序不一样



### 奇偶校验码

计算机计算、存取、传输过程当中，由于计算机元器件有可能发生故障，或者因为某些环境噪音干扰导致二进制数据发生错误，数据校验相关问题（知错能改）

##### 校验原理

两台计算机之间进行数据的传输

| 信息 | A    | B    | C    | D    |
| ---- | ---- | ---- | ---- | ---- |
| 编码 | 00   | 01   | 10   | 11   |

4种 - 2bit

编码方案优化

| 信息 | A    | B    | C    | D    |
| ---- | ---- | ---- | ---- | ---- |
| 编码 | 100  | 001  | 010  | 111  |

增加一个冗余的校验位

3bit映射到4个合法状态(有四个冗余的非法状态)

由若干代码组成的一个字叫<span style="color:red">码字</span> 

将两个码字足一进行对比，具有不同的位的个数为<span style="color:red">两个码字之间的距离</span> 

一种编码方案可能有若干个合法码字，各合法码字之间的距离称为<span style="color:red">"码距" - d</span> 

当d = 1的编码方案，无检错能力。当d = 2时，有检错能力。当d >= 3 时，若设计合理，可能具有检错，纠错能力。



##### 奇偶校验

只具有检错能力

奇校验码：整个校验码（有效信息位和校验位）中"1"的个数为奇数

偶校验码：整个校验码（有效信息位和校验位）中"1"的个数为偶数

Eg:给出两个编码1001101和1010111的奇校验码和偶校验码

设最高位为校验位，余7位是校验位，则对应的奇偶校验码为

| 原始编码 | 奇校验码                                | 偶校验码                                |
| -------- | --------------------------------------- | --------------------------------------- |
| 1001101  | <span style="color:red">1</span>1001101 | <span style="color:red">0</span>1001101 |
| 1010111  | <span style="color:red">0</span>1010111 | <span style="color:red">1</span>1010111 |

局限性：偶数个bit发生跳变，奇偶校验码检测不出错误

偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验位

<span style="color:green">异或（模2加）⌖</span> 

<span style="color:green">0 ⌖ 0 = 0</span> 

<span style="color:green">1 ⌖ 1 = 0</span> 

<span style="color:green">0 ⌖ 1 = 1</span> 

<span style="color:green">1 ⌖ 0 = 1</span> 

1001101 偶校验位 1 ⌖ 0 ⌖ 0 ⌖ 1 ⌖ 1 ⌖ 0 ⌖ 1 =  0

1010111 偶校验位 1 ⌖ 0 ⌖ 1 ⌖ 0 ⌖ 1 ⌖ 1 ⌖ 1 =  1

<span style="color:green">进行校验（所有位进行异或，若结果为1说明错误）</span> 



### 海明校验码

Richard Hamming 也可称为汉明校验码，对信息纠错领域的贡献，十分巨大，获得1968年图灵奖

##### 基本思路

奇偶校验码缺陷：只能发现奇数位错误，但无法确定哪一位出错

<span style="color:red">海明码设计思路：</span> 将信息位分组进行偶校验 --> 多个校验位 - K个

K个校验位能携带多种状态信息（对/错，错在哪里）--> 多个校验位标注出错的位置

思路需要探讨的问题：n个信息位分为多少个分组，n个信息位怎么分派到各个分组当中



需要多少校验位？

信息位n、校验位k (2^k种状态)，信息位 + 校验位 = n + k --> 2^k  > = n + k +1(n + k中任意一位都可能出错，1中正确状态)

| n    | 1    | 2~4  | 5~11 | 12~26 | 27~57 | 58~120 |
| ---- | ---- | ---- | ---- | ----- | ----- | ------ |
| k    | 2    | 3    | 4    | 5     | 6     | 7      |



##### 求解步骤

```mermaid
graph LR
A(确定校验位数量)-->B(确定校验位的分布)-->C(求校验位的值)-->D(检错纠错)
```



信息位0101

1，确定海明码位数：2^k  > = n + k +1 => k = 3，总共有7位这么多

设信息位D4D3D2D1(1010)，共4位，校验位P3P2P1，共三位，对应海明码为：H7H6H5H4H3H2H1

2，确定校验位分布

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1    | 0    | 1    | 0    | 0    | 1    | 0    |

校验位Pi放在海明位位2^i-1的位置上=> 和二进制权值上升关系相符合

P3 -- 2^3-1 = 4

P2 -- 2^2-1 = 2

P1 -- 2^1-1 = 1

信息位按顺序放到其余位置

3，求校验位的值

​                            ↓↓↓(P3P2P1)

D1-> H3 : 3 -> 0  1  1

D2-> H5:  5 -> 1  0  1

D3-> H6 : 6 -> 1  1  0

D4-> H7:  7 -> 1  1  1

三个分组分别进行偶校验

P1的分组：P1 = H3 ⌖ H5 ⌖ H7 = D1 ⌖ D2 ⌖ D4 = 0 ⌖ 1 ⌖ 1 = 0

P2的分组：P2 = H3 ⌖ H6 ⌖ H7 = D1 ⌖ D3 ⌖ D4 = 0 ⌖ 0 ⌖ 1 = 1

P3的分组：P3 = H5 ⌖ H6 ⌖ H7 = D2 ⌖ D3 ⌖ D4 = 1 ⌖ 0 ⌖ 1 = 0

4，纠错（偶校验 = 0）

校验方程

S1 = P1 ⌖ D1 ⌖ D2 ⌖ D4

S2 = P2 ⌖ D1 ⌖ D3 ⌖ D4

S3 = P3 ⌖ D2 ⌖ D3 ⌖ D4

接收方接收到：1010010

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1    | 0    | 1    | 0    | 0    | 1    | 0    |

S1 = P1 ⌖ D1 ⌖ D2 ⌖ D4 = 0 ⌖ 0 ⌖ 1 ⌖ 1 = 0

S2 = P2 ⌖ D1 ⌖ D3 ⌖ D4 = 1 ⌖ 0 ⌖ 0 ⌖ 1 = 0

S3 = P3 ⌖ D2 ⌖ D3 ⌖ D4 = 0 ⌖ 1 ⌖ 0 ⌖ 1 = 0

接收方接收到：10100<span style="color:red">0</span>0

| H7   | H6   | H5   | H4   | H3   | H2                               | H1   |
| ---- | ---- | ---- | ---- | ---- | -------------------------------- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2                               | P1   |
| 1    | 0    | 1    | 0    | 0    | <span style="color:red">0</span> | 0    |

S1 = P1 ⌖ D1 ⌖ D2 ⌖ D4 = 0 ⌖ 0 ⌖ 1 ⌖ 1 = 0

S2 = P2 ⌖ D1 ⌖ D3 ⌖ D4 = <span style="color:red">0</span> ⌖ 0 ⌖ 0 ⌖ 1 = <span style="color:red">1</span>  (找到错误) => 第 010(S3S2S1)位出错 => 十进制2

S3 = P3 ⌖ D2 ⌖ D3 ⌖ D4 = 0 ⌖ 1 ⌖ 0 ⌖ 1 = 0

海明码纠错原理图

![Screen Shot 2022-07-19 at 13.25.21](/Users/hexiaogou/Library/Application Support/typora-user-images/Screen Shot 2022-07-19 at 13.25.21.png)

做题会遇到的情况(从小 -> 大)

设信息位为D1D2D3D4(1010)，共四位，校验位P1P2P3，共3位，对应的海明码为：H1H2H3H4H5H6H7

【注意】海明码

纠错能力：1位

检错能力：2位

但是如果发生两个bit位的跳变，之前的方案无法区分是两个bit位错误还是一个bit位错误

实际使用过程中需在最首部加上<span style="color:red">全校验位</span> ，对整体进行偶校验

| <span style="color:red">H8</span> | H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| --------------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| P全                               | D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1                                 | 1    | 0    | 1    | 0    | 0    | 1    | 0    |

S3S2S1  = 000 且全体偶校验成功 -> 无错误

S3S2S1 <>000 且全体偶校验失败 -> 有1位错误，纠正即可

S3S2S1 <>000 且全体偶校验成功 -> 有2位错误，需重传



### 循环冗余校验码

CRC码（Cyclic Redundancy Check, CRC）

##### CRC码基本思想

882 / 7 = 126 ... 0  

883 / 7 = 126 ... 1

852 / 7 = 121 ... 5

数据错误导致余数改变 -- 检测到错误

=> 循环冗余校验码思想：

数据发送、接收方约定一个<span style="color:red">除数</span>【二进制】

 <span style="color:green">K个信息位</span> + <span style="color:green">R个校验位</span> 作为被除数，添加校验位后需保证<span style="color:red">除法</span>的余数为0

接收方接收到数据后，进行<span style="color:red">除法</span>检查余数是否为0

若余数非0说明出错，则进行重传或纠错-单bit位纠错

##### 如何构造

关键要素：<span style="color:red">除数、被除数</span> 

设生成多项式为G(x) = x^3 + x^2 + 1，信息码为101001，求对应CRC码

分析：G(x) = x^3 + x^2 + 1

​		 = 1 \* x^3 + 1 \* x^2 + 0 \* x^1 + 1 \* x^0

=> G(x) = 1101，指明了除数是多少

K位信息码：101001

1，确定K、R以及多项式对应的二进制码

K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3  => 校验码位数N = K + R = 9

G(x) = 1101

R：校验位校验码 / G(x)  ...=0

2，移位

信息码左移R位，低位补0 -- 计算机硬件的处理方式 101001<span style="color:cyan">000</span> 

3，相除

对移位后的信息码，用生成多项式进行<span style="color:red">模2除法</span>，产生余数(得到3位也就是R位的余数)

 101001<span style="color:cyan">000</span> / G(x) = 101001<span style="color:cyan">000</span> / 1101 ...= 001，余数只比除数少1位

=> CRC码 =101001 001

CRC码 / G(x) = 000

模2除法，模2减法（等同于模2加，也就是异或运算），后三位进行模2减

101001<span style="color:cyan">000</span> / 1101

除数4位

##### 如何检错纠错

4，检错纠错

【注】发送方、接收方提起约定好G(x)，即约定好了除数

发送：101001 001，记为：C9C8C7C6C5C4C3C2C1

接收：101001 001，用G(x) 1101 进行模2除，余数为 000，代表没错出错

接收：101001 0<span style="color:red">1</span>1，用G(x) 1101 进行模2除，余数为 010，代表出错

接收：101001 <span style="color:red">1</span>01，用G(x) 1101 进行模2除，余数为 100，代表出错

余数是3bit信息，总共有8种状态 < 9(K+R)，信息位太长导致，余数十进制不能跟C对应的序列号对应，就看起来CRC码没有纠错能力



信息位：0100

生成多项式：G(x) = x^3 + x^2 + 1 （1101）

K = 4 ，R = 3

移位：0100 000

0100 000 / G(x)  ... =  011

CRC =<span style="color:red">0100 011</span>   C7C6C5C4C3C2C1

| 接受     | 余数 | 出错位 |
| -------- | ---- | ------ |
| 0100 010 | 001  | 1      |
| 0100 001 | 010  | 2      |
| 0100 111 | 100  | 3      |
| 0101 011 | 101  | 4      |
| 0110 011 | 111  | 5      |
| 0000 011 | 011  | 6      |
| 1100 011 | 110  | 7      |

余数十进制不能跟C对应的序列号对应，但是对于确定的生成多项式，无论信息位怎样变化，出错位与余数是相对应的，如果位数没有超过余数所能表示的范围，余数和出错位之间是一一对应关系。

所以循环冗余校验码是有纠错功能的

K个信息位，R个校验位，若生成多项式选择得当，且2^R => K + R +1，则CRC可纠正1位错。

在实际使用中，一般只用来“检错”

理论上可以证明循环冗余校验的检错能力有以下特点

1）可以检测出所有奇数个错误

2）可以检测出所有双bit错误

3）可以检测出所有小于等于校验位长度的连续错误



### 定点数的表示

##### 定点数 vs 浮点数

定点数：小数点的位置固定 Eg:996.007 -- 常规计数

浮点数：小数点的位置不固定 Eg:996007 \* 10^2 --科学计数法

二进制的定点数、浮点数也类似

 

##### 无符号数

整个机器字长的全部二进制单位均为数值位，没有符号位，相当于绝对值

1001 1100B = 1 x 2^7 + 0 x 2^6 + 0 x 2^5 + 1 x 2^4 + 1 x 2^3 + 1 x 2^2 + 0 x 2^1 + 0 x 2^0 = 128 + 16 + 8 + 4 = 156D

| 2^16  | 2^15  | 2^14  | 2^13 | 2^12 | 2^11 | 2^10 | 2^9  | 2^8  | 2^7  | 2^6  | 2^5  | 2^4  |
| ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 65536 | 32768 | 16384 | 8192 | 4096 | 2048 | 1024 | 512  | 256  | 128  | 64   | 32   | 16   |

表示范围：前提条件 - 要多少个bit位来表示一个无符号数

8位二进制数：2^8种不同的状态 -- 0000 0000 ～ 1111 1111 真值

 = 1 x 2^7 + 1 x 2^6 + 1 x 2^5 + 1 x 2^4 + 1 x 2^3 + 1 x 2^2 + 1 x 2^1 + 1 x 2^0  = 2^8 - 1 = 255

x + 1 = 2^8 => x =  2^8 - 1 = 255

=> <span style="color:red">n 位无符号数表示范围： 0 ～ 2^n -1</span> 

 通常只有无符号整数，没有无符号小数 - unsigned只能修饰 (int、long整数相关的数据类型关键字)

##### 有符号数

有符号数的定点表示

定点整数

| X0     | X1   | X2   | ...  | Xn   |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 符号位 |      |      |      |      |      |

​                     											 |------------------------------------------->数值部分<-------------------------------------|    小数点位置   |

最高位为符号位：0（正）1（负）

定点小数

| X0     |      | X1   | ...  | Xn-1 | Xn   |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 符号位 |      |      |      |      |      |

​                     										|    小数点位置    |--------------------------------------------->数值部分<-------------------------------------|

定点整数、定点小数数值部分也称尾数



19.75 -- 整数19单独保存小数0.75单独保存

【注】可用<span style="color:red">原码、反码、补码</span> 三种方式来表示定点整数和定点小数。还可以用<span style="color:red">移码</span> 表示定点整数

若真值为x，则用<span style="color:red">[x]原、[x]反、[x]补、[x]移</span> 分别表示真值对应的原码、反码、补码、移码

##### 有符号数-原码

<span style="color:red">原码</span> ：用尾数表示真值的绝对值，符号位“0/1”对应“正/负”

若机器字长为n +1，则尾数占n位

定点整数用原码表示：

| 符号 | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 1    | 0    | 0    | 1    | 1    |
| 1    | 0    | 0    | 1    | 0    | 0    | 1    | 1    |

2^6 ~ 2^0 尾数的位权，2^0的位置基于小数的位置（隐含）

+19D = 0 001 0011 即 [x]原 = 0 001 0011

-19D  = 1 001 0011

若未明确机器字长，-19D  = [x]原 =  1,1 0011，省掉补加的0

若机器字长为n + 1，<span style="color:red">原码整数</span> 的表示范围为：<span style="color:red">-(2^n -1) <= x<= +(2^n -1)</span> (关于原点对称)

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式，因此n +1个二进制位，可以表示2^(n+1)种不同的状态，但是表示的真值数为2^(n+1) -1个数

定点小数用原码表示：

| 符号 | 2^-1 | 2^-2 | 2^-3 | 2^-4 | 2^-5 | 2^-6 | 2^-7 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    |

2^-1 ~ 2^-7 尾数的位权，2^-1的位置基于小数的位置（隐含）

+0.75D = 0 110 0000

-0.75D  = 1 110 0000

若机器字长为n + 1，<span style="color:red">原码小数</span> 的表示范围为：<span style="color:red">-(1 - 2^-n) <= x<= +(1 - 2^-n)</span> (关于原点对称)

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式



##### 有符号数-反码

<span style="color:red">反码</span> ：若符号位为0，则反码与原码相同。<span style="color:red">若符号位为1，则数值位全部取反</span> 

x = +19D  [x]原 = 0 001 0011，[x]反 = 0 001 0011

x = -19D   [x]原 = 1 001 0011，[x]反 = 1 110 1100

+0.75D = 0 110 0000	 [x]原 = 0 110 0000，[x]反 = 0 110 0000

-0.75D  = 1 110 0000	 [x]原 = 1 110 0000，[x]反 = 1 001 1111

若机器字长为n + 1，<span style="color:red">反码整数</span> 的表示范围为：<span style="color:red">-(2^n -1) <= x<= +(2^n -1)</span> (关于原点对称)(符号位为负时数值位原码-反码一一对应相反变化)

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式

[+0]原 = 0 000 0000	[+0]反 = 0 000 0000

[-0]原 = 1 000 0000	 [-0]反 = 1 111 1111



若机器字长为n + 1，<span style="color:red">反码小数</span> 的表示范围为：<span style="color:red">-(1 - 2^-n) <= x<= +(1 - 2^-n)</span> (关于原点对称)

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式

[+0]原 = 0 000 0000	[+0]反 = 0 000 0000

[-0]原 = 1 000 0000	 [-0]反 = 1 111 1111

<span style="color:red">反码只是原码转变为补码的一个中间状态，实际中并没有什么卵用</span> ，计算机不会用反码直接进行加减乘除的计算

##### 有符号数-补码

基于反码得到补码

<span style="color:red">补码</span> ：整数的补码 = 原码，负数的补码 = 反码末尾 + 1 (<span style="color:red">要考虑进位</span> )

x = +19D  [x]原 = 0 001 0011，[x]反 = 0 001 0011，[x]补 = 0 001 0011

x = -19D   [x]原 = 1 001 0011，[x]反 = 1 110 1100，[x]补 = 1 110 1101

+0.75D = 0 110 0000	 [x]原 = 0 110 0000，[x]反 = 0 110 0000，[x]补 =  0 110 0000

-0.75D  = 1 110 0000	 [x]原 = 1 110 0000，[x]反 = 1 001 1111，[x]补 = 1 010 0000

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式

[+0]原 = 0 000 0000	[+0]反 = 0 000 0000，[+0]补 = 0 000 0000

[-0]原 = 1 000 0000	 [-0]反 = 1 111 1111， [-0]补 = 0 000 0000（更高位进的1会被丢弃）

<span style="color:red">[注]补码真值0只有一种表示形式</span> 

原码中真值0多出来的二进制状态，有个特别的规定

定点整数补码[x]补 = 1000 0000 表示 = -2^7

若机器字长为n + 1，<span style="color:red">补码整数</span> 的表示范围为：<span style="color:red">-(2^n) <= x<= +(2^n -1)</span> ，比原码多表示一个-(2^n)

定点小数补码[x]补 = 1000 0000 表示 x = -1

若机器字长为n + 1，<span style="color:red">补码小数</span> 的表示范围为：<span style="color:red">-1 <= x<= +(1 - 2^-n)</span>，比原码多表示一个-1

<span style="color:red">将负数补码转换为原码的方法相同：尾数位取反，末尾 +1</span> 

##### 有符号数-移码

<span style="color:red">移码</span> ：补码的基础上将符号位取反。<span style="color:green">移码只能用于表示整数</span> 

x = +19D  [x]原 = 0 001 0011，[x]反 = 0 001 0011，[x]补 = 0 001 0011，[x]反 = 1 001 0011

x = -19D   [x]原 = 1 001 0011，[x]反 = 1 110 1100，[x]补 = 1 110 1101，[x]反 = 0 110 1101

真值0有<span style="color:red">+0</span> 和<span style="color:red">-0</span> 两种形式

[+0]原 = 0 000 0000	[+0]反 = 0 000 0000，[+0]补 = 0 000 0000，[+0]反 = 1 000 0000

[-0]原 = 1 000 0000	 [-0]反 = 1 111 1111， [-0]补 = 0 000 0000（更高位进的1会被丢弃）， [-0]反 = 1 000 0000

若机器字长为n + 1，<span style="color:red">移码整数</span> 的表示范围为：<span style="color:red">-(2^n) <= x<= +(2^n -1)</span> （移码和补码是一一对应关系）

如果把移码所有二进制位看作无符号数，真值增大时，移码无符号数也是逐一递增的，移码表示的整数很方便计算机硬件对比大小，后续的浮点数，会大量使用移码



Eg下列各种码对应的真值

[x]原 = 1000 1101 = -13

[x]反 = 1000 1101 = {[x]原 = 1 111 0010} = -(64 + 32 + 16 + 2) = -114

[x]补 = 1000 1101 = {[x]反 = 1 000 1100 } = {[x]原 = 1 111 0011} = -(64 + 32 + 16 + 2+1)  = -115

[x]移 = 1000 1101 =  {[x]补 = 0 000 1101 } = {[x]原 = 0 000 1101 } = (8+4 +1) = 13

[x]移 = 0000 1101 =  {[x]补 = 1 000 1101 }  = {[x]反 = 1 000 1100 } = {[x]原 = 1 111 0011} = -(64 + 32 + 16 + 2+1)  = -115



[x]原 = 0000 1101 = 13

[x]反 = 0000 1101 = 13

[x]补 = 0000 1101 =13

[x]移 = 0000 1101 = {[x]补 = 1 000 1101 } = {[x]原 = 1 111 0011 } = -(64 + 32 +16 + 2 +1) = - 115

技巧：有[x]补快速求[-x]补的方法

常用方法 [x]补 --> [x]原 --> [-x]补

更快捷的方法(tip)：符号位、数值位全部取反，末位 + 1

[x]补 = 0000 1101 =13 、[-x]补 = 1111 0010 + 1 = 1111 0100 = -(64 + 32 + 16 + 4) = -116

[x]补 = 1000 1101 = -115、[-x]补 = 0111 0010 + 1 = 0 111 0011 = +(64 + 32 + 16 + 2 + 1) = +115



### 原、补、移码作用

##### 加、减运算

​	 0000 1110

\+  1000 1110 = 1001 1100

假设是无符号数：14D + 142D = 156D

原码表示有符号数：14D + (-14D) = 0D <> 1001 1100

Need 正 + 负 ---> {正 - (-负)}  即 { 正 -正}

​	 0000 1110

\-   0000 1110 = 0000 0000

=> 计算机涉及 + / - 时，必须考虑到符号位

使用原码运算

加法 -- 用加法器完成，加法器硬件电路设计比较容易

减法 -- 用减法器完成，减法器硬件电路设计比较困难

....

硬件既要设计加法，又要设计减法器，设备成本增加，同时复杂度也增加



能否用加法代替减法？

##### 用加法代替减法

10 - 3 = 7

10 + 9 = 19 19/12  ...= 7

<<数论中>> 19 mod 12 = 7 模相当于余数

-3 === 9(mod 12) 模12 ，即 -3 mod 12 = 9，9 mod 12 = 9



模运算的性质

带余除法 -- 设x，m ⍷ Z，m > 0 则存在唯一决定的整数q和r，使得 x = qm + r， 0 <= r < m

x mod m = r

-3 mod 12 =  ?、9 mod 12 = ？

-3 = (-1) x 12  + 9

9 = 0 x 12 + 9

21 = 1 x 12 +9

-15 = (-2) x 12 + 9

.....

=> (mod 12) -3 、9 、21、-15  ... 完全等价

(mod 12)把所有整数分为12类（余数0～11）、(mod 12)相同的余数，都是同一类，都是等价的

即 10 + (-3)、10 + 9、10  + 21...在(mod 12)的条件下效果相同

等价的数在计算机加减的时候，可以相互替换

|(-3)| + |9| = 12 二者绝对值之和等于模，显然每个数的绝对值都小于模的、(-3)和9互为补数

在(mod m)的条件下，若能找到负数的补数，就可以用正数的加法来等价代替减法

模 - a的绝对值 = a的补数（正数）补码原生的定义

这样就可以用加法替代减法

​     0000 1110  		0000 1110

\-   0000 1110 = +   1111 0010 = 1 0000 0000 (8bit) = 0000 0000 = 0

[-14]补 ={[-14]原 = 1000 1110} = {[-14]反 = 1111 0001 +1} = 1111 0010

​               ={[14]补 = 0000 1110} = 1111 0001 +1 = 1111 0010

8bit  - 0000 0000 ~ 1111 1111 - unsigned 0 ~ 2^8 -1 => 天然(mod 2^8)

\-   0000 1110 --> (mod 2^8)  - 0000 1110 = 1 0000 0000 - 0000 1110 =1111 0010(模 - a的绝对值 = a的补数)

补码的作用：让减法操作转变为加法操作，ALU无需集成减法器,执行加法操作时，符号位一起参与运算,节省硬件成本



|-14| = |\-   0000 1110|  = |1000 1110| = 0000 1110

[-14]补 = 1 0000 0000 - 0000 1110

0000 1110反 = 1111 0001

0000 1110 + 0000 1110反 +1  = 0000 1110  + 1111 0001 +1  = 1111 1111 +1 = mod 2^8

原码求补码时，符号位不变，尾数取反 + 1

Eg:

​                       0101 1000  	   0101 1000 

88 - 66 = \-   0100 0010 = \+  1011 1110 = 1 0001 0110 = 0001 0110 = 16 + 4 + 2 = 22D

进位后最高位的信息，能反映出是否溢出

-100 + -100 = 0000 0000 + 1001 1100 + 1001 1100 = 1 0011 1000 = 0011 1000 = 56 <span style="color:red">✕</span> 溢出



移码表示的整数很方便计算机硬件对比大小，后续的浮点数，会大量使用移码



### 移位运算

定点数移位运算怎么实现

##### 算术移位

r进制：Kn Kn-1 .... K2 K1 K0 K-1 K-2 ... Km-1 Km = Kn \* r^n + Kn-1 \* r^n-1 +... + K2 \* r^2 + K1\* r^1 +K0 \* r^0 + K-1 \* r^-1 + K-2 \* r^-2 + Km-1 \* r^m-1 + Km \* r^m

985.211 

9852.11	小数点后移一位相当于 x 10^1

98521.1	小数点后移二位相当于 x 10^2

98.5211	小数点前移一位相当于 / 10^1

9.85211	小数点前移二位相当于 / 10^2

.点位置变换后，相当于改变了每个数位的位权

算术移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法



原码的算术移位

| ...  | 符   | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 原码 | 1    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | .    |

原码的算术移位 -- 符号位保持不变，仅对数值位进行移位

-20D 

算术右移：1 0001 010 = -10D，右移移位：-20 / 2^1 = -10

​					  1 0000 101 = -5D，右移移位：-20 / 2^2 = -5

​					  1 0000 010 = -2D，右移移位：-20 / 2^3= -2

右移：高位补0，低位舍弃。若舍弃位=0，则相当于/2，若舍弃位不等于0，则会<span style="color:purple">丢失精度</span> 

算术左移：1 0101 000 = -40D，左移移位：-20 \* 2^1 = -40

​					  1 1010 000 = -80D，左移移位：-20 \* 2^2 = -80

​					  1 0100 000 = -32D，丢失精度

左移：低位补0，高位舍弃。若舍弃位=0，则相当于\*2，若舍弃位不等于0，则会<span style="color:purple">丢失精度</span> 



反码的算术移位

| ...  | 符   | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 原码 | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | .    |
| 反码 | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 1    | .    |
| 原码 | 1    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | .    |
| 反码 | 1    | 1    | 1    | 0    | 1    | 0    | 1    | 1    | .    |

正数反码、原码一致，算术移位一致

负数数值位与原码相反，因此<span style="color:red">负数反码的移位运算规则如下</span>：

右移：高位补1，低位舍弃

左移：低位补1，高位舍弃 



补码的算术移位

正数反码、原码一致，算术移位一致，都是用0来补充移动之后出现的空位

| ...  | 符   | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 原码 | 1    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | .    |
| 反码 | 1    | 1    | 1    | 0    | 1    | 0    | 1    | 1    | .    |
| 补码 | 1    | 1    | 1    | 0    | 1    | 1    | 0    | 0    | .    |

-20D

反码末尾 + 1 = 补码，导致反码当中更靠后的1变成0，会发生进位，知道往前的高位第一个0出现

<span style="color:red">规律：负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码</span> 

<span style="color:red">负数补码</span> 的算术移位规则如下：

右移(同反码)，高位补1，低位舍弃

左移(同原码)，高位舍弃，低位补1

算术移位总结：左移相当于 x2，右移相当于 /2。由于位数有限，因此有时候无法用算术移位精确地等效于乘除法。



Eg: -20D x 7 = -20 x 111B =-20 x ( 2^0 + 2^1+ 2^2 )= 不左移 + 左移一位 + 左移二位 = -20 + -40 + -80 = -140D 

算术移位的电路设计起来不复杂

##### 逻辑移位

逻辑右移：高位补0，低位舍弃

逻辑左移：低位补0，高位舍弃

可以把逻辑移位看作是对无符号数的算术移位

逻辑移位的应用举例：

RGB (red green blue)自然界中所有的颜色都是依据红绿蓝这三种颜色一定配比来组成

R = 102  = 0110 0110

G = 139 = 1000 1011

B = 139 = 1000 1011

用3Byte存储无符号数102，并逻辑左移16位 ①

用3Byte存储无符号数139，并逻辑左移8位    ②

用3Byte存储无符号数139                                      ③

① + ② + ③ =3Byte RGB值

 

##### 循环移位

Circle 移出的位，补充到空出来的位置

带进位位的循环左移： <span style="color:grey">1</span>  1011 0101 >8bit 数据的加法，数值最高位放到进位位，进位位补到空位

循环移位很适合把自己高字节和低字节进行一个调换

汉字 - 啊 - 2Byte

大端存储: 高字节 ---> 低字节

小端存储: 低字节 ---> 高字节

大端和小端存储的转换，使用循环移位



### 加减法溢出判断

##### 原码的加减法运算

14 +（-14）= 0000 1110 + 1000 1110 = 1 001 1100 结果错误

14 - 14  = 0000 1110 - 0000 1110 = 0000 0000 结果正确，用减法器实现

A + B  A是被加数、B是加数，A/B 都有可能是正/负数

正 + 正 ---> 绝对值做加法，结果为正

负 + 负 ---> 绝对值做加法，结果为负

正 + 负 ---> 绝对值大的减绝对值小的，符号同绝对值大的数

负 + 正 ---> 绝对值大的减绝对值小的，符号同绝对值大的数 

原码的减法运算，"减数"符号取反，转为加法

原码加减法运算，硬件设计专门的减法器，比较复杂和有难度

原码的加法运算，如果 A B都是相同正或者相同负，有可能出现溢出的情况



##### 补码的加减法运算

设机器字长为8位（含一位符号位）， A = 15，B = -24，求[A + B]补，[A -B]补

A = +1111 -> 0 000 1111(原) --> 0 000 1111(补)

B = -11000 -> 1 001 1000(原) --> 1 11 01 000(补)

[A + B]补 = [A]补 + [B]补 = 0 000 1111 + 1 11 01 000 = 1 1110111(补) = 1 0001001(原) = -9

补码 --> 原码（数值位全部取反 + 1/负数补码中，最右边的1及右边同原码，最右边的1的左边同反码）

[A -B]补 = [A]补 + [-B]补 = 0 000 1111 + 0 001 1000 = 0 0100 111 = 39

 [B]补 （所有位取反，末尾+1/最右边的1右边不边，左边全部取反） = [-B]补 

对于补码来说，无论加法还是减法，最后都转变成加法，由加法器实现运算，符号位也参与运算

C = 124，求[A+C]补和[B-C]补 （-117/+108均溢出）

##### 溢出判断

计算机硬件实现溢出判断的逻辑（补码的加法运算如何判断溢出）

下溢｜负数区        0       正数区 ｜上溢

8位补码：-128 ～ 127

只有“正数 + 正数”，才会上溢 --- 正 + 正 = 负

只有“负数 + 负数”，才会下溢 --- 负 + 负 = 正

方法一：采用一位符号位，设A的符号位为As，B的符号位为Bs，运算结果的符号为Ss，则溢出的逻辑表达式为

```properties
V = AsBsSs^ + As^Bs^Ss（离散数学）
```

若V = 0 表示无溢出，若V = 1表示溢出

ABC = A与B与C 

A + B + C 表示A 或 B 或 C

A^ 表示 非A

方法二：采用一位符号位，根据数据位进位情况判断溢出

上溢：符号位的进位Cs为0，最高数值为的进位C1为1

下溢：符号位的进位Cs为1，最高数值为的进位C1为0

及Cs与C1不同时有溢出

处理不同的逻辑符号：异或⌖

```properties
V = Cs ⌖ C1
```

若V = 0 ，表示无溢出，若V = 1，表示有溢出

方法三：采用双符号位的补码来表示一个数

正数符号为00，负数符号为11，第一个高位符号位为正确的，第二个低符号位为实际的

记两个符号位为Ss1Ss2

```properties
V = Ss1 ⌖ Ss2
```

若V = 0 ，表示无溢出，若V = 1，表示有溢出

【注】双符号位补码又称：模4补码，单符号位补码又称：模2补码

实际存储只存储一个符号位，运算时会复制一个符号位

##### 符号扩展

给定的机器字长的原码，补码表示不了那么大的范围从而出现了溢出，如何让原码，补码表示更大的数，从而避免溢出的发生。

int --> long 容易想到的办法就是把短数据--> 长数据，多出来的那些位怎么填补

Eg : 8位 --> 16位

正整数（原、反、补码都一样，高位添加0）

负整数（原在符号位与数值位之间添加0，反码符号位与数字位之间添加1，补码符号位与数字位之间添加1）

正小数（原、反、补码都一样，尾部添加0）

负小数（原码末尾补0，反码末尾补1，补码末尾补0-最后一个1右半部分与原码一致，左半部分与反码一致）



### 原码的乘法运算

##### 乘法运算实现思想

手算乘法（十进制）

r进制：KnKn-1....K2K1K0K-1K-2..K-m= Kn x rⁿ + Kn-1 x rⁿ-1 .... + K2 x r² + K1 x r¹ + K0 x r⁰ + K-1 x r^-1 + K-2 x r^-2 + K-n x r^-m

二进制：0.1101 x 0.1011 = 0.1000 1111

乘数：0.1011 = 1 x 2^-1 + 0 x 2^-2 + 1 x 2^-3 + 1 x 2^-4

被乘数：0.1101 = 1101 x 2^-4

0.1101 x 0.1011 = (1101 x 1 x 2^-8) + (1101 x 1 x 2^-7) + (1101 x 0 x 2^-6) + (1101 x 1 x 2^-5) [2^-5用移位实现，右移5位]

考虑用机器实现？实际数字有正负，符号位如何处理？成绩的位数扩大一倍，如何处理？4个位积都要保存下来最后统一相加？

##### 原码一位乘法

设机器字长 = n +1 = 5 位（含1位符号位），[x]原 = 1.1101，[y]原 = 0.1011，采用原码一位乘法求xy

符号单独处理：符号位 = Xs ⌖ Ys，数值位<span style="color:red"> 取绝对值</span>进行乘法运算

[|x|]原 = 0.1101，[|y|]原 = 0.1011

穿越运算器的基本组成：ALU算术逻辑单元，通过复杂的电路实现算数运算、逻辑运算

ACC：累加器，用于存放操作数或运算结果

MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果

X：通用操作数寄存器，用于存放操作数

| ---                        | ---  | 加         | 减         | 乘             | 除           |
| -------------------------- | ---- | ---------- | ---------- | -------------- | ------------ |
| Accumulator                | ACC  | 被加数、和 | 被减数、差 | 乘积高位       | 被除数、余数 |
| Multiple-Quitient Register | MQ   |            |            | 乘数、乘积低位 | 商           |
| Arithmetic and Logic Unit  | X    | 加数       | 减数       | 被乘数         | 除数         |

<img src="/Users/hexiaogou/Library/Application Support/typora-user-images/Screen Shot 2022-08-15 at 11.42.04.png" alt="Screen Shot 2022-08-15 at 11.42.04" style="zoom:30%;" />

在正式进行乘法之前ACC置0

MQ从低位往高位移动取当前位

若当前位为1，则ACC + 被乘数；若当前位为0，则ACC + 0

```properties
(ACC) + (X) -> ACC
00000 + 01101 = 01101

```

ACC的最后一位会移到MQ得高位，逻辑右移，高位补0

MQ中乘数的符号位不用参与运算

ACC中定点小数点的位置时隐含的

最终结果ACC的符号位 = Xs ⌖ Ys

总结：原码一位乘法，n轮加法、移位完成



### 补码的乘法运算

##### 补码一位乘法

设机器字长 = n +1 = 5 位（含1位符号位，n=4），[x]= -0.1101，[y] = +0.1011，采用<span style="color:red">Booth算法</span> 求xy

原码一位乘法，n轮加法、移位完成

每次加法<span style="color:red">可能+0、+[|x|]原</span> （根据当前MQ中最低位来确定加什么）

```properties
MQ最低位为1时 = (ACC) + [|x|]原
MQ最低位为0时 = (ACC) + 0
```

每次移位是“逻辑右移”

原码符号位不参与运算

------

补码一位乘法，n轮加法、<span style="color:red">最后再多来一次加法</span> 

每次加法<span style="color:red">可能+0、+[x]补、+[-x]补</span> （根据当前MQ中最低位和辅助位来确定加什么）

```properties
辅助位 - MQ最低位为1时  = (ACC) + [x]补
辅助位 - MQ最低位为0时  = (ACC) + 0
辅助位 - MQ最低位为-1时 = (ACC) + [-x]补
```

每次移位是“<span style="color:red">补码的算数右移</span> ”

<span style="color:red">补码符号位参与运算</span> 

补码乘法运算硬件构成

[x]补 = 1.0011、[-x]补 = 0.1101、[y]补 = 0.1011

<img src="/Users/hexiaogou/Library/Application Support/typora-user-images/Screen Shot 2022-08-15 at 15.15.26.png" alt="Screen Shot 2022-08-15 at 15.15.26" style="zoom:50%;" />

辅助位，MQ的容量多扩展了一位，<span style="color:red">辅助位初始值为0。每次移位会使MQ的最低位顶替原本的辅助位（事实上MQ共n+2位）</span> 

MQ的最低位表示当前参与乘法的那一位

<span style="color:red"> 由于计算机系统所有寄存器是统一的，所以ACC、X也是n+2位，因此采用双符号位补码运算</span>

MQ存的是单符号位的补码

会有专门的辅助电路实现[-x]补的转换

手算模拟

(高位部分积)				(低位部分积/乘数) 				说明

​				00.0000				0.1011|0							起始情况

+[-x]补  00.1101															Y4Y5 = 10,	Y5 - Y4 = -1，则+[-x]补

———————————⌍

​				00.1101

右移       00.0110 ---------  10.101|10						右移部分积和乘数

+0 		  00.0000															Y4Y5 = 11,	Y5 - Y4 = 0，则+0														

———————————⌍

​				00.0110

右移	   00.0011 --------- 010.10|110						右移部分积和乘数

+[x]补  11.0011															Y4Y5 = 01,	Y5 - Y4 = 1，则+[x]补	

———————————⌍

​				11.0110    

右移	   11.1011 --------- 0010.1|0110						右移部分积和乘数                                                   

+[-x]补  00.1101															Y4Y5 = 10,	Y5 - Y4 = -1，则+[-x]补

———————————⌍

​				00.1000

右移	   00.0100 --------- <u>00010</u>.|10110						右移部分积和乘数         

+[x]补   11.0011															Y4Y5 = 01,	Y5 - Y4 = 1，则+[x]补

———————————⌍

​				<u>11.0111</u>

[x\*y]补 = 11.0111 00010

Y5 指的是辅助位，Y4指代的是MQ的最低位，



### 原码的除法运算
